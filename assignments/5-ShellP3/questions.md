1. Your shell forks multiple child processes when executing piped commands. How does your implementation ensure that all child processes complete before the shell continues accepting user input? What would happen if you forgot to call waitpid() on all child processes?

In my implementation, every time I fork a child process for a piped command, I store the pid in an array. After each of the child processes are forked, I then use a loop that calls waitpid() on each of the stored pid's. This makes sure that the parent process waits until all of the children processes have finished executing before accepting new input. If I forgot to call waitpid() on all child processes then the parent wouldn't wait for them to complete which would cause issues if new commands started to run while the previous ones are still executing. If we didn't call waitpid() then the parent process would continue executing before the child processes finished executing resulting to issues such as not being able to get the child's exit status and maybe commands not executing in the correct order which results in incorrect output.

2. The dup2() function is used to redirect input and output file descriptors. Explain why it is necessary to close unused pipe ends after calling dup2(). What could go wrong if you leave pipes open?

It is necessary to close unused pipe ends after calling dup2() because dup2() duplicates the source_fd into the target_fd but does not close the original. We need to close the original pipe file descriptors that are not needed anymore. If we leave pipes open then we may not recieve an EOF signal to indicate that we are at the end of the file. This might cause the parent or child processes to wait for input that it is never going to recieve because the pip was left open and the EOF signal was never recieved. If you don't close pipes then data might be transferred incorrectly between the processes which may result in incorrect behavior or incorrect output. If you don't close the original pipes after copying with `dup2()`, you have introduced a **descriptor leak**; this could cause your program to run out of available file descriptors.

3. Your shell recognizes built-in commands (cd, exit, dragon). Unlike external commands, built-in commands do not require execvp(). Why is cd implemented as a built-in rather than an external command? What challenges would arise if cd were implemented as an external process?

cd is implemented as a built-in rather than an external because the cd command functionality is to change the current working directory of the shell. If cd was implemented as an external command, it would run in a forked seperate child process that was created and then any changes would only be affected in the child process. The current working directory would stay unchanged and the cd command would not work as expected. By making it a built-in command then the shell can instantly change the working directory without having to fork and creating a new child process. 

4. Currently, your shell supports a fixed number of piped commands (CMD_MAX). How would you modify your implementation to allow an arbitrary number of piped commands while still handling memory allocation efficiently? What trade-offs would you need to consider?

If I had to allow an arbitray number of piped commands then I would have to modify my implementation to allocate memory dynamically based on how many commands my program was given. I would have to allocate memory dynamically for everywhere in my program that I used the CMD_MAX argument. I would use malloc to change the size based on the number of arguments my program was given. The tradeoffs that I may need to consider is correctly freeing the memory that I allocate, making sure that I do not allocate too much memory, and making sure that my code is fast enough to handle an arbitrary number of piped commands and output within a normal time frame.
